name: MIXER

on:
  workflow_dispatch:
    inputs:
      voice_url:
        description: 'URL mp3/wav с голосом (Cloudinary secure_url)'
        required: false
      job_id:
        description: 'Опционально: ID партии (для ручного запуска)'
        required: false
  repository_dispatch:
    types: [mix, mix_audio]

concurrency:
  group: mixer
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install ffmpeg & jq
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

      # ====== РЕЗОЛВ ВХОДНЫХ ДАННЫХ (с защитами) ======
      - name: Resolve inputs (VOICE_URL / JOB_ID / MAKE_CALLBACK_URL)
        env:
          SECRET_CALLBACK: ${{ secrets.MAKE_CALLBACK_URL }}
        shell: bash
        run: |
          set -Eeuo pipefail

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            [[ -n "${{ github.event.inputs.voice_url }}" ]] && VOICE_URL="${{ github.event.inputs.voice_url }}"
            [[ -n "${{ github.event.inputs.job_id }}"   ]] && JOB_ID="${{ github.event.inputs.job_id }}"
            MAKE_CALLBACK_URL="$SECRET_CALLBACK"
          else
            [[ -n "${{ github.event.client_payload.voice_url }}"       ]] && VOICE_URL="${{ github.event.client_payload.voice_url }}"
            if [[ -z "${VOICE_URL:-}" && -n "${{ github.event.client_payload.final_audio_url }}" ]]; then
              VOICE_URL="${{ github.event.client_payload.final_audio_url }}"
            fi
            [[ -n "${{ github.event.client_payload.job_id }}"         ]] && JOB_ID="${{ github.event.client_payload.job_id }}"
            if [[ -n "${{ github.event.client_payload.make_callback_url }}" ]]; then
              MAKE_CALLBACK_URL="${{ github.event.client_payload.make_callback_url }}"
            else
              MAKE_CALLBACK_URL="$SECRET_CALLBACK"
            fi
          fi

          JOB_ID="$(printf "%s" "${JOB_ID:-}" | tr -d '\r' | xargs | tr -cd '[:alnum:]_-')"
          if [[ -z "$JOB_ID" || "$JOB_ID" == "prokis_jobs" ]]; then
            JOB_ID="$(date +%s)-$RANDOM"
          fi

          {
            echo "VOICE_URL=${VOICE_URL:-}"
            echo "JOB_ID=$JOB_ID"
            echo "MAKE_CALLBACK_URL=$MAKE_CALLBACK_URL"
          } >> "$GITHUB_ENV"

          echo ">> Resolved"
          echo "   VOICE_URL=${VOICE_URL:-<empty>}"
          echo "   JOB_ID=$JOB_ID"
          echo "   MAKE_CALLBACK_URL=$(echo "$MAKE_CALLBACK_URL" | sed -E 's#^(https?://[^/]+).*#\1#')"

      - name: Debug client_payload (for repo_dispatch)
        if: ${{ github.event_name == 'repository_dispatch' }}
        run: |
          echo 'client_payload JSON:'
          echo '${{ toJSON(github.event.client_payload) }}'

      # ====== ПРОВЕРКА СЕКРЕТОВ ======
      - name: Check required secrets presence
        env:
          INTRO_URL:         ${{ secrets.INTRO_URL }}
          OUTRO_URL:         ${{ secrets.OUTRO_URL }}
          BG_URL:            ${{ secrets.BG_URL }}
          CLD_CLOUD_NAME:    ${{ secrets.CLD_CLOUD_NAME }}
          CLD_UPLOAD_PRESET: ${{ secrets.CLD_UPLOAD_PRESET }}
        shell: bash
        run: |
          set -Eeuo pipefail
          miss=0
          for k in INTRO_URL OUTRO_URL BG_URL CLD_CLOUD_NAME CLD_UPLOAD_PRESET; do
            v="${!k:-}"
            if [[ -z "$v" ]]; then
              echo "::error title=Missing secret::$k is empty or not configured"; miss=1
            fi
          done
          [[ $miss -ne 0 ]] && { echo "Some secrets are missing. See errors above."; exit 1; }
          echo "All required secrets are present."

      # ====== ВАЛИДАЦИЯ URL-ОВ ======
      - name: Validate & sanitize URLs
        env:
          INTRO_URL_RAW: ${{ secrets.INTRO_URL }}
          OUTRO_URL_RAW: ${{ secrets.OUTRO_URL }}
          BG_URL_RAW:    ${{ secrets.BG_URL }}
        shell: bash
        run: |
          set -Eeuo pipefail
          trim(){ printf "%s" "$1" | tr -d '\r' | xargs; }

          VOICE_URL="$(trim "${VOICE_URL:-}")"
          INTRO_URL="$(trim "$INTRO_URL_RAW")"
          OUTRO_URL="$(trim "$OUTRO_URL_RAW")"
          BG_URL="$(trim "$BG_URL_RAW")"
          MAKE_CALLBACK_URL="$(trim "$MAKE_CALLBACK_URL")"

          req_url(){ [[ -z "$2" ]] && { echo "::error title=$1 missing::Set $1"; exit 1; }
                     echo "$2" | grep -qi '^https\?://' || { echo "::error title=$1 invalid::Must start with http/https"; exit 1; }; }

          req_url "VOICE_URL" "$VOICE_URL"
          req_url "INTRO_URL" "$INTRO_URL"
          req_url "OUTRO_URL" "$OUTRO_URL"
          req_url "BG_URL"    "$BG_URL"
          req_url "MAKE_CALLBACK_URL" "$MAKE_CALLBACK_URL"

          {
            echo "VOICE_URL=$VOICE_URL"
            echo "INTRO_URL=$INTRO_URL"
            echo "OUTRO_URL=$OUTRO_URL"
            echo "BG_URL=$BG_URL"
            echo "MAKE_CALLBACK_URL=$MAKE_CALLBACK_URL"
          } >> "$GITHUB_ENV"

          echo "VOICE_URL host: $(echo "$VOICE_URL" | sed -E 's#^(https?://[^/]+).*#\1#')/…"
          echo "Callback host: $(echo "$MAKE_CALLBACK_URL" | sed -E 's#^(https?://[^/]+).*#\1#')"

      # ====== АУДИО-ПАЙПЛАЙН ======
      - name: Download input files
        shell: bash
        run: |
          set -Eeuo pipefail
          curl -fSL "$VOICE_URL" -o voice_input
          curl -fSL "$INTRO_URL" -o intro.mp3
          curl -fSL "$OUTRO_URL" -o outro.mp3
          curl -fSL "$BG_URL"    -o bg.mp3
          ls -lh

      - name: Validate audio stream (voice)
        shell: bash
        run: |
          set -Eeuo pipefail
          ffprobe -hide_banner -loglevel error -select_streams a:0 -show_streams -of csv=p=0 voice_input

      - name: Convert all to WAV 44.1kHz stereo
        shell: bash
        run: |
          set -Eeuo pipefail
          ffmpeg -hide_banner -y -i intro.mp3   -ar 44100 -ac 2 intro.wav
          ffmpeg -hide_banner -y -i outro.mp3   -ar 44100 -ac 2 outro.wav
          ffmpeg -hide_banner -y -i bg.mp3      -ar 44100 -ac 2 bg.wav
          ffmpeg -hide_banner -y -i voice_input -ar 44100 -ac 2 voice.wav

      # === НОВОЕ: нормализация интро/BG/аутро к одной громкости
      - name: Normalize intro/bg/outro to one loudness
        env:
          TARGET_LUFS: "-16"
          TRUE_PEAK:   "-1.5"
        run: |
          set -Eeuo pipefail
          ffmpeg -hide_banner -y -i intro.wav -af "loudnorm=I=$TARGET_LUFS:TP=$TRUE_PEAK:LRA=11" -ar 44100 -ac 2 intro_n.wav
          ffmpeg -hide_banner -y -i bg.wav    -af "loudnorm=I=$TARGET_LUFS:TP=$TRUE_PEAK:LRA=11" -ar 44100 -ac 2 bg_n.wav
          ffmpeg -hide_banner -y -i outro.wav -af "loudnorm=I=$TARGET_LUFS:TP=$TRUE_PEAK:LRA=11" -ar 44100 -ac 2 outro_n.wav

      - name: Loop normalized BG to voice duration
        run: |
          set -Eeuo pipefail
          VDUR=$(ffprobe -v error -show_entries format=duration -of csv=p=0 voice.wav)
          ffmpeg -hide_banner -y -stream_loop -1 -i bg_n.wav -t "$VDUR" bg_loop.wav

      - name: Mix voice and normalized BG
        env:
          BG_MIX_DB: "-4"   # 0 = ровно с голосом; -3..-6 dB = тише под речь
        run: |
          set -Eeuo pipefail
          ffmpeg -hide_banner -y -i voice.wav -i bg_loop.wav \
            -filter_complex "[1:a]volume=${BG_MIX_DB}dB[bg];[0:a][bg]amix=inputs=2:duration=first:dropout_transition=2[aout]" \
            -map "[aout]" -ar 44100 -ac 2 voice_mix.wav

      # === НОВОЕ: Нормализуем voice+BG к тому же -16 LUFS
      - name: Normalize voice_mix to same loudness
        env:
          TARGET_LUFS: "-16"
          TRUE_PEAK:   "-1.5"
        run: |
          set -Eeuo pipefail
          ffmpeg -hide_banner -y -i voice_mix.wav -af "loudnorm=I=$TARGET_LUFS:TP=$TRUE_PEAK:LRA=11" -ar 44100 -ac 2 voice_mix_n.wav

      - name: Concat intro + voice_mix + outro (all normalized)
        run: |
          set -Eeuo pipefail
          ffmpeg -hide_banner -y -i intro_n.wav -i voice_mix_n.wav -i outro_n.wav \
            -filter_complex "[0:a][1:a][2:a]concat=n=3:v=0:a=1[a]" \
            -map "[a]" -ar 44100 result_premix.wav

      # финальный лимитер (легко), без повторной глобальной нормализации
      - name: Peak limit and encode MP3
        run: |
          set -Eeuo pipefail
          ffmpeg -hide_banner -y -i result_premix.wav -af "alimiter=limit=0.98" -ar 44100 -b:a 160k result.mp3

      - name: Measure final duration
        shell: bash
        run: |
          set -Eeuo pipefail
          DUR=$(ffprobe -v error -show_entries format=duration -of csv=p=0 result.mp3)
          echo "FINAL_DURATION=$DUR" >> "$GITHUB_ENV"
          echo "Duration (s): $DUR"

      - name: Upload to Cloudinary (video resource type for audio)
        env:
          CLD_CLOUD_NAME:    ${{ secrets.CLD_CLOUD_NAME }}
          CLD_UPLOAD_PRESET: ${{ secrets.CLD_UPLOAD_PRESET }}
        shell: bash
        run: |
          set -Eeuo pipefail
          URL=$(curl -s -X POST "https://api.cloudinary.com/v1_1/$CLD_CLOUD_NAME/video/upload" \
            -F file=@result.mp3 \
            -F upload_preset="$CLD_UPLOAD_PRESET" \
            -F folder=prokis | jq -r '.secure_url')
          [[ -z "$URL" || "$URL" == "null" ]] && { echo "::error title=Cloudinary::Upload failed"; exit 1; }
          echo "FINAL_URL=$URL" >> "$GITHUB_ENV"
          echo "Uploaded: $URL"

      - name: Callback to Make
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "Callback -> $MAKE_CALLBACK_URL"

          jq -n \
            --arg job_id "$JOB_ID" \
            --arg final_audio_url "$FINAL_URL" \
            --arg lufs "-16" \
            --arg duration "$FINAL_DURATION" \
            '{job_id:$job_id, final_audio_url:$final_audio_url, lufs: ($lufs|tonumber), duration: ($duration|tonumber)}' \
          | tee payload.json

          echo "::group::POST Make callback"
          http_code=$(curl -w "%{http_code}" --fail --show-error -s -o resp.json \
            -H "Content-Type: application/json" \
            -A "MixerGH/1.0" \
            -X POST -d @payload.json "$MAKE_CALLBACK_URL") || { echo "HTTP failed"; cat resp.json || true; exit 1; }
          echo "HTTP $http_code"
          echo "Response:"; cat resp.json || true
          echo "::endgroup::"
